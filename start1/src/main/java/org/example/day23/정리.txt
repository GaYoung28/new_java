1. 변수 : 기본형(원시형, 정수/실수/문자1/논리형-true/false), 참조형(배열, 객체,.....)         -> p.38
           정수(byte,short,int(4byte), long), 실수(float(4byte), double), 문자1(char,2byte), 논리(1byte) -> p.39

           <변수의 종류 기준>
           기준1) 범위
                    클래스 아래 선언 - 전역변수
                    클래스 안쪽 메서드/제어문 선언 - 지역변수
           기준2) 자동초기화
                    전역변수 - 자동초기화 o
                    지역변수 - 자동초기화 x
           기준3) 객체생성
                    인스턴스 변수 - 객체생성 후 접근 가능
                    static 변수(정적변수) - 객체 생성 상관 없이 클래스 이름으로 바로 접근 가능
           기준4) 저장
                    값이 들어가면 - 기본형
                    주소가 들어가면 - 참조형
           기준5) 저장값/주소를 변경 여부
                    변경 가능 - 변수
                    변경 불가능 - 상수


           <기본형과 참조형>
           초기화 방법 - int i = 0;, float f = 0.0f;. long ->L 붙여야함 String s = null;, int[]n = null;
            -> 기본형이나 참조형이냐에 따라서 초기화 방법 다름


2. 연산자(기호) - 산술(+, -, *, /(몫), %(나머지)),
                     비교(==, !=, >(초과), >=: 부등호부터 먼저 쓰기 (이상),<, <= / 산술연산자나 비교연산자는 이항연산자(항이 2개필요)
                     논리 (!, &&, ||)                   (이항연산자)
                     증감 (++, -- ) -> 일항연산자(단항연산자)
                     삼항연산자(조건 ? 맞으면이거 : 틀리면 이거)


3. 제어문 - 순차문, 반복문(while(조건), for(조건)), 조건문(if(조건), switch(변수))
자체 브레이크 for문, if 문-> 알아서 멈춤 / switch는 브레이크 달아줘야함
while, for, if (조건)-> boolean으로
switch(변수)  : 더 제약적 / 변수로 int, String, char 가능 / long X, 실수 X

반복문 안에서 if - break는 반복문의



4. 배열 - int[] n = new int[5]; // 전체 만들어진 변수개수 = 7개 (0으로 초기화된것 5개({0,0,0,0,0}, length(읽기전용변수), n(주소) -> n[0], n[n.length-1], n[4]/ n[5] = array boundary에서 벗어난 오류


------------------------------------
5. 객체/클래스

   A.java(클래스 이름 : public class A ) -- javac A.java --> A.class --> JVM(javaA) --> 기계어
- A.java의 클래스 이름 A로 동일해야함


6. 상속 - extends

public class Truck(자식클래스, 하위클래스, 서브클래스) extends Car(부모, 상위클래스 , 수퍼클래스)
Car c = new Truck(); // 큰 <-자동으로  Car(자동형변환, 업캐스팅)  -- 작
Truck t = (Truck)new Car(); //작 <--강제로 Truck(강제형변환, 다운캐스팅) -- 큰

object (9개 메서드) : 최상위클래스 , 가장 큰
object이 가지고 있는 메서드 : toString(), equals(), hashCode() 등

생성자 - 필드값 초기화 목적으로, 오버로딩 가능, 생성자가 하나도 없는 경우 기본 생성자가 만들어짐
           생성자를 하나 넣으면 자동생성되지 않음.
           생성자메서드 - return 쓰지 않음, (무조건 void이므로) / 클래스명과 동일하게 써야함


7. 형변환 / 제너릭

제너릭 - 형변환 X, 객체 생성 시 타입을 지정할 수 있는 문법
           ArrayList<String>, ArrayList<Integer>
           ArrayList<String> list = new ArrayList() <>; (꺽새안에 스트링 써도되고 안써도됨)
           ArrayList<double> ---> xxx

컬렉션 - 순서 (List) , 중복X(set), 키/값(Map), 선입선출(Queue)

스레드 - 만드는 방법 ) 상속, 인터페이스구현,  멀티스레드(스레드 여러개)
           start() : 스레드 실행 시작 / run() : 동시에 처리될 내용을 코딩



8. 인터페이스/추상클래스

인터페이스 - 추상메서드만 가질 수 있음(불완전한 메서드, 구현이 빠져있는 메서드), 상수만 !!
추상클래스 - 일반메서드 + 추상메서드 1개 이상, 변수 + 상수 (클래스에서 추상메서드를 1개 이상 가지면 무조건 추상클래스)
===> 공통점 ) 추상메서드 가짐 , 객체생성 XX, 일반클래스로 구현해서 사용해야한다.


9.스트림(외부자원과 연결한 통로) : inputStream, OutputStream(1바이트 처리, 모든데이터 타입 다)
                                         : Reader, Writer(2바이트 처리, 문자타입처리만)

10. intStream, DoubleStream, Stream<String> : stream(), filter(), map(), distinct()
    람다식 ( -> 문법) : 조건(함수형 인터페이스인 경우에만 = 추상메서드를 하나만 가지는 )
    (파라메터) -> {처리내용} ==> {] 처리내용이 1줄이면 생략가능! return 도 생략가능


11. 객체지향 2대원칙
: 응집도(클래스에는 하나의 역할만 정의, 높게 만들어야함)
  결합도(다른 부품간의 결합은 낮게 설정, 다른 부품으로 교체 가능)


12. final 개념 - 변수에 붙으면 상수라는 의미, 클래스에 붙으면 상속불가능

13. try(예외가 발생할 것 같은 코드)~catch(여러개, 예외처리코드)
     finally(예외상황과 상관없이 항상 실행하는 코드)

14. 주석 //, /* ~ */
